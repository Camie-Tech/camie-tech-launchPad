{
  "Email Service (Nodemailer + Supabase, Rate Limiting, Templates)": {
    "prefix": "emailServiceTs",
    "scope": "typescript",
    "body": [
      "import nodemailer from \"nodemailer\";",
      "import { config } from \"../config\";",
      "import { LRUCache } from \"lru-cache\";",
      "import { RateLimiter } from \"limiter\";",
      "import { Readable } from \"stream\";",
      "import { supabase } from \"./supabaseClient\";",
      "",
      "interface EmailOptions {",
      "  to: string | string[];",
      "  subject: string;",
      "  text?: string;",
      "  html?: string;",
      "  attachments?: Array<{",
      "    filename?: string;",
      "    content?: string | Buffer | Readable;",
      "    path?: string;",
      "    href?: string;",
      "    httpHeaders?: Record<string, string>;",
      "    contentType?: string;",
      "    contentDisposition?: \"attachment\" | \"inline\";",
      "    encoding?: string;",
      "    headers?: Record<string, string>;",
      "    raw?: string | Buffer | Readable;",
      "  }>;",
      "  template?: string;",
      "  context?: Record<string, any>;",
      "}",
      "",
      "interface EmailProvider {",
      "  sendMail(",
      "    options: EmailOptions",
      "  ): Promise<{ success: boolean; messageId?: string; error?: string }>;",
      "}",
      "",
      "class NodemailerProvider implements EmailProvider {",
      "  private transporter: nodemailer.Transporter;",
      "",
      "  public async verifyConnection(): Promise<void> {",
      "    await this.transporter.verify();",
      "  }",
      "",
      "  constructor() {",
      "    this.transporter = nodemailer.createTransport({",
      "      host: config.email.host,",
      "      port: config.email.port,",
      "      secure: config.email.secure,",
      "      auth: config.email.auth,",
      "      pool: true,",
      "      maxConnections: 5,",
      "      maxMessages: 100,",
      "      rateDelta: 1000,",
      "      rateLimit: 5,",
      "    });",
      "  }",
      "",
      "  async sendMail(",
      "    options: EmailOptions",
      "  ): Promise<{ success: boolean; messageId?: string; error?: string }> {",
      "    try {",
      "      const info = await this.transporter.sendMail({",
      "        from: config.email.from,",
      "        to: options.to,",
      "        subject: options.subject,",
      "        text: options.text,",
      "        html: options.html,",
      "        attachments: options.attachments,",
      "      });",
      "",
      "      return {",
      "        success: true,",
      "        messageId: info.messageId,",
      "      };",
      "    } catch (error: any) {",
      "      return {",
      "        success: false,",
      "        error: error.message,",
      "      };",
      "    }",
      "  }",
      "}",
      "",
      "class SupabaseProvider implements EmailProvider {",
      "  async sendMail(",
      "    options: EmailOptions",
      "  ): Promise<{ success: boolean; messageId?: string; error?: string }> {",
      "    try {",
      "      const { error } = await supabase.auth.admin.createUser({",
      "        email: Array.isArray(options.to) ? options.to[0] : options.to,",
      "        email_confirm: true,",
      "        user_metadata: {",
      "          subject: options.subject,",
      "          content: options.html || options.text,",
      "        },",
      "      });",
      "",
      "      if (error) {",
      "        throw error;",
      "      }",
      "",
      "      return {",
      "        success: true,",
      "      };",
      "    } catch (error: any) {",
      "      return {",
      "        success: false,",
      "        error: error.message,",
      "      };",
      "    }",
      "  }",
      "}",
      "",
      "class EmailService {",
      "  private templateCache!: LRUCache<string, string>;",
      "  private rateLimiter!: RateLimiter;",
      "  private static instance: EmailService;",
      "  private nodemailerProvider!: NodemailerProvider;",
      "  private supabaseProvider!: SupabaseProvider;",
      "",
      "  private constructor() {",
      "    this.validateConfig();",
      "    this.initializeProviders();",
      "    this.initializeCache();",
      "    this.initializeRateLimiter();",
      "  }",
      "",
      "  private initializeProviders() {",
      "    this.nodemailerProvider = new NodemailerProvider();",
      "    this.supabaseProvider = new SupabaseProvider();",
      "  }",
      "",
      "  public static getInstance(): EmailService {",
      "    if (!EmailService.instance) {",
      "      EmailService.instance = new EmailService();",
      "    }",
      "    return EmailService.instance;",
      "  }",
      "",
      "  private validateConfig() {",
      "    const requiredFields = [\"host\", \"port\", \"auth.user\", \"auth.pass\", \"from\"];",
      "    const missingFields = requiredFields.filter((field) => {",
      "      const value = field",
      "        .split(\".\")",
      "        .reduce((obj: any, key) => obj?.[key], config.email);",
      "      return !value;",
      "    });",
      "",
      "    if (missingFields.length > 0) {",
      "      throw new Error(",
      "        `Missing required email configuration: ${missingFields.join(\", \")}`",
      "      );",
      "    }",
      "  }",
      "",
      "  private initializeCache() {",
      "    this.templateCache = new LRUCache({",
      "      max: 100,",
      "      ttl: 1000 * 60 * 60,",
      "    });",
      "  }",
      "",
      "  private initializeRateLimiter() {",
      "    this.rateLimiter = new RateLimiter({",
      "      tokensPerInterval: config.email.rateLimit.max,",
      "      interval: config.email.rateLimit.windowMs,",
      "      fireImmediately: true,",
      "    });",
      "  }",
      "",
      "  private async retry<T>(",
      "    operation: () => Promise<T>,",
      "    retries = config.email.retryAttempts,",
      "    delay = config.email.retryDelay",
      "  ): Promise<T> {",
      "    try {",
      "      return await operation();",
      "    } catch (error) {",
      "      if (retries > 0) {",
      "        await new Promise((resolve) => setTimeout(resolve, delay));",
      "        return this.retry(operation, retries - 1, delay * 2);",
      "      }",
      "      throw error;",
      "    }",
      "  }",
      "",
      "  private async checkRateLimit(): Promise<void> {",
      "    const remainingTokens = await this.rateLimiter.removeTokens(1);",
      "    if (remainingTokens < 0) {",
      "      throw new Error(\"Rate limit exceeded. Please try again later.\");",
      "    }",
      "  }",
      "",
      "  private async processTemplate(",
      "    template: string,",
      "    context: Record<string, any>",
      "  ): Promise<string> {",
      "    let processedTemplate = this.templateCache.get(template) || template;",
      "",
      "    if (!this.templateCache.has(template)) {",
      "      this.templateCache.set(template, template);",
      "    }",
      "",
      "    Object.entries(context).forEach(([key, value]) => {",
      "      processedTemplate = processedTemplate.replace(",
      "        new RegExp(`{{${key}}}`, \"g\"),",
      "        String(value)",
      "      );",
      "    });",
      "",
      "    return processedTemplate;",
      "  }",
      "",
      "  private async validateEmail(email: string | string[]): Promise<void> {",
      "    const emailRegex = /^[^\\s@]+@[^\\s@]+\\.[^\\s@]+$/;",
      "    const emails = Array.isArray(email) ? email : [email];",
      "",
      "    const invalidEmails = emails.filter((e) => !emailRegex.test(e));",
      "    if (invalidEmails.length > 0) {",
      "      throw new Error(`Invalid email addresses: ${invalidEmails.join(\", \")}`);",
      "    }",
      "  }",
      "",
      "  public async sendEmail(",
      "    options: EmailOptions,",
      "    useSupabase: boolean = false",
      "  ): Promise<{ success: boolean; messageId?: string; error?: string }> {",
      "    try {",
      "      await this.validateEmail(options.to);",
      "      await this.checkRateLimit();",
      "",
      "      let html = options.html;",
      "      if (options.template && options.context) {",
      "        html = await this.processTemplate(options.template, options.context);",
      "      }",
      "",
      "      const emailOptions = {",
      "        ...options,",
      "        html,",
      "      };",
      "",
      "      // Try Supabase first if specified",
      "      if (useSupabase) {",
      "        const result = await this.retry(() =>",
      "          this.supabaseProvider.sendMail(emailOptions)",
      "        );",
      "        if (result.success) {",
      "          return result;",
      "        }",
      "      }",
      "",
      "      // Fallback to Nodemailer or use it as primary if useSupabase is false",
      "      return await this.retry(() =>",
      "        this.nodemailerProvider.sendMail(emailOptions)",
      "      );",
      "    } catch (error: any) {",
      "      console.error(\"Email sending failed:\", {",
      "        error: error.message,",
      "        to: options.to,",
      "        subject: options.subject,",
      "        timestamp: new Date().toISOString(),",
      "      });",
      "",
      "      return {",
      "        success: false,",
      "        error: error.message,",
      "      };",
      "    }",
      "  }",
      "",
      "  public async sendWelcomeEmail(",
      "    email: string,",
      "    confirmationCode: number",
      "  ): Promise<{ success: boolean; error?: string }> {",
      "    const welcomeTemplate = `",
      "      <h1>Welcome to AirAgent!</h1>",
      "        <p>Thank you for joining our platform. We're excited to have you on board!</p>",
      "",
      "        <p><strong>Your confirmation code:</strong></p>",
      "        <p style=\"font-size: 1.5em; font-weight: bold; color: #2c3e50;\">${confirmationCode}</p>",
      "",
      "        <p>Use this code to verify your email address and complete your registration.</p>",
      "",
      "        <p>If you have any questions, feel free to reach out to our support team.</p>",
      "",
      "    `;",
      "",
      "    return this.sendEmail({",
      "      to: email,",
      "      subject: \"Welcome to AirAgent!\",",
      "      html: welcomeTemplate,",
      "    });",
      "  }",
      "",
      "  public async sendTemplateEmail(",
      "    options: Omit<EmailOptions, \"html\"> & {",
      "      template: string;",
      "      context: Record<string, any>;",
      "    },",
      "    useSupabase: boolean = false",
      "  ) {",
      "    return this.sendEmail(",
      "      {",
      "        ...options,",
      "        html: await this.processTemplate(options.template, options.context),",
      "      },",
      "      useSupabase",
      "    );",
      "  }",
      "",
      "  public async verifyConnection(): Promise<boolean> {",
      "    try {",
      "      await this.nodemailerProvider.verifyConnection();",
      "      return true;",
      "    } catch (error) {",
      "      console.error(\"Email service connection verification failed:\", error);",
      "      return false;",
      "    }",
      "  }",
      "",
      "  public async testEmailProviders(): Promise<{",
      "    nodemailer: { success: boolean; error?: string };",
      "    supabase: { success: boolean; error?: string };",
      "  }> {",
      "    const testEmails = [\"timileyinolayuwa@gmail.com\", \"ebentim4@gmail.com\"];",
      "    const testTemplate = `",
      "        <h2>Email Service Test</h2>",
      "        <p>This is a test email from AirAgent2.0</p>",
      "        <p>If you received this email, it means the email service is working correctly.</p>",
      "        <p>Test details:</p>",
      "        <ul>",
      "            <li>Time: ${new Date().toISOString()}</li>",
      "            <li>Environment: ${process.env.NODE_ENV || \"development\"}</li>",
      "        </ul>",
      "    `;",
      "",
      "    try {",
      "      // Test Nodemailer",
      "      const nodemailerResult = await this.sendEmail(",
      "        {",
      "          to: testEmails,",
      "          subject: \"AirAgent2.0 - Nodemailer Test\",",
      "          html: testTemplate,",
      "        },",
      "        false",
      "      );",
      "",
      "      // Test Supabase",
      "      const supabaseResult = await this.sendEmail(",
      "        {",
      "          to: testEmails[0], // Supabase can only send to one email at a time",
      "          subject: \"AirAgent2.0 - Supabase Test\",",
      "          html: testTemplate,",
      "        },",
      "        true",
      "      );",
      "",
      "      return {",
      "        nodemailer: {",
      "          success: nodemailerResult.success,",
      "          error: nodemailerResult.error,",
      "        },",
      "        supabase: {",
      "          success: supabaseResult.success,",
      "          error: supabaseResult.error,",
      "        },",
      "      };",
      "    } catch (error: any) {",
      "      return {",
      "        nodemailer: { success: false, error: \"Failed to test Nodemailer\" },",
      "        supabase: { success: false, error: \"Failed to test Supabase\" },",
      "      };",
      "    }",
      "  }",
      "}",
      "",
      "export default EmailService.getInstance();"
    ],
    "description": "Comprehensive email service with Nodemailer, Supabase, rate limiting, template support, and provider fallback."
  },
  "Supabase Auth Service (TypeScript)": {
    "prefix": "supabaseAuthServiceTs",
    "scope": "typescript",
    "body": [
      "import { createClient } from '@supabase/supabase-js';",
      "const supabase = createClient(process.env.SUPABASE_URL!, process.env.SUPABASE_ANON_KEY!);",
      "",
      "export class SupabaseAuthService {",
      "  static async signUp(email: string, password: string) {",
      "    const { data, error } = await supabase.auth.signUp({ email, password });",
      "    if (error) throw error;",
      "    return data;",
      "  }",
      "",
      "  static async signIn(email: string, password: string) {",
      "    const { data, error } = await supabase.auth.signInWithPassword({ email, password });",
      "    if (error) throw error;",
      "    return data;",
      "  }",
      "",
      "  static async resetPassword(email: string, redirectUrl: string) {",
      "    const { error } = await supabase.auth.resetPasswordForEmail(email, { redirectTo: redirectUrl });",
      "    if (error) throw error;",
      "  }",
      "",
      "  static async sendOTP(phone: string) {",
      "    const { error } = await supabase.auth.signInWithOtp({ phone, options: { channel: 'sms' } });",
      "    if (error) throw error;",
      "  }",
      "}"
    ],
    "description": "Supabase authentication service for sign up, sign in, password reset, and OTP."
  },
  "Firebase Auth Service (TypeScript)": {
    "prefix": "firebaseAuthServiceTs",
    "scope": "typescript",
    "body": [
      "import { getAuth, AuthError } from 'firebase/auth';",
      "",
      "export class FirebaseAuthService {",
      "  static async signUp(email: string, password: string) {",
      "    try {",
      "      const auth = getAuth();",
      "      const { user } = await auth.createUserWithEmailAndPassword(auth, email, password);",
      "      return user;",
      "    } catch (error) {",
      "      throw error as AuthError;",
      "    }",
      "  }",
      "",
      "  static async signIn(email: string, password: string) {",
      "    try {",
      "      const auth = getAuth();",
      "      const { user } = await auth.signInWithEmailAndPassword(auth, email, password);",
      "      return user;",
      "    } catch (error) {",
      "      throw error as AuthError;",
      "    }",
      "  }",
      "",
      "  static async resetPassword(email: string) {",
      "    try {",
      "      const auth = getAuth();",
      "      await auth.sendPasswordResetEmail(auth, email);",
      "    } catch (error) {",
      "      throw error as AuthError;",
      "    }",
      "  }",
      "}"
    ],
    "description": "Firebase authentication service for sign up, sign in, and password reset."
  },
  "Google Auth Service (TypeScript)": {
    "prefix": "googleAuthServiceTs",
    "scope": "typescript",
    "body": [
      "import { OAuth2Client } from 'google-auth-library';",
      "",
      "const GOOGLE_CLIENT_ID = process.env.GOOGLE_CLIENT_ID;",
      "const googleClient = new OAuth2Client(GOOGLE_CLIENT_ID);",
      "",
      "export class GoogleAuthService {",
      "  static async verifyToken(token: string) {",
      "    const ticket = await googleClient.verifyIdToken({",
      "      idToken: token,",
      "      audience: GOOGLE_CLIENT_ID",
      "    });",
      "    return ticket.getPayload();",
      "  }",
      "}"
    ],
    "description": "Google ID token verification using google-auth-library."
  },
  "Custom Email/Password Auth (TypeScript)": {
    "prefix": "customEmailPasswordAuthTs",
    "scope": "typescript",
    "body": [
      "import bcrypt from 'bcryptjs';",
      "",
      "export class CustomAuthService {",
      "  static async hashPassword(password: string) {",
      "    const salt = await bcrypt.genSalt(10);",
      "    return bcrypt.hash(password, salt);",
      "  }",
      "",
      "  static async verifyPassword(password: string, hash: string) {",
      "    return bcrypt.compare(password, hash);",
      "  }",
      "",
      "  static async signUp(email: string, password: string) {",
      "    const hashed = await this.hashPassword(password);",
      "    // Save email and hashed password to DB",
      "  }",
      "",
      "  static async signIn(email: string, password: string) {",
      "    // Fetch user by email, get hashed password from DB",
      "    // Use verifyPassword to check",
      "  }",
      "}"
    ],
    "description": "Custom email/password authentication using bcrypt."
  }
}
